-- hds header_start
--
-- VHDL Entity MP2_2.Cache_Controller.interface
--
-- Created:
--          by - skim41.stdt (eesn21.ews.uiuc.edu)
--          at - 16:14:47 10/18/04
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2001.5 (Build 170)
--
-- hds header_end
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;


LIBRARY MP2_2;
USE MP2_2.LC3b_types.all;

ENTITY Cache_Controller IS
   PORT( 
      Address       : IN     LC3b_word;
      Clk           : IN     std_logic;
      Data_cacheout : IN     LC3b_CacheLine64;
      Data_wordout  : IN     LC3b_word;
      Dataout       : IN     LC3b_word;
      MREAD_L       : IN     std_logic;
      MWRITEH_L     : IN     std_logic;
      MWRITEL_L     : IN     std_logic;
      PMRESP_H      : IN     std_logic;
      Reset_L       : IN     std_logic;
      lrusel        : IN     std_logic;
      tag0match     : IN     std_logic;
      tag1match     : IN     std_logic;
      DataIn        : OUT    LC3b_word;
      LineSel       : OUT    std_logic;
      MRESP_H       : OUT    std_logic;
      PMAddress     : OUT    LC3b_word;
      PMDataOut     : OUT    LC3b_CacheLine64;
      PMREAD_L      : OUT    std_logic;
      PMWRITE_L     : OUT    std_logic;
      WriteEn0      : OUT    std_logic;
      WriteEn1      : OUT    std_logic;
      index         : OUT    LC3b_index4;
      lruload       : OUT    std_logic;
      lruupdate     : OUT    std_logic;
      offset        : OUT    LC3b_offset3;
      tag           : OUT    LC3b_tag9
   );

-- Declarations

END Cache_Controller ;

-- hds interface_end
--
-- VHDL Architecture MP2_2.Cache_Controller.fsm
--
-- Created:
--          by - skim41.stdt (eesn21.ews.uiuc.edu)
--          at - 16:14:47 10/18/04
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2001.5 (Build 170)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;


LIBRARY MP2_2;
USE MP2_2.LC3b_types.all;

ARCHITECTURE fsm OF Cache_Controller IS

   -- Architecture Declarations
   TYPE STATE_TYPE IS (
      Read_hit,
      Read_miss,
      Write_hit2,
      Write_hit1,
      Write_hit3,
      Reset,
      UpdateData,
      Write_miss1,
      Write_miss2,
      Write_miss3,
      UpdateLRU
   );

   -- State vector declaration
   ATTRIBUTE state_vector : string;
   ATTRIBUTE state_vector OF fsm : ARCHITECTURE IS "current_state" ;


   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE ;
   SIGNAL next_state : STATE_TYPE ;

BEGIN

   ----------------------------------------------------------------------------
   clocked : PROCESS(
      Clk,
      Reset_L
   )
   ----------------------------------------------------------------------------
   BEGIN
      IF (Reset_L = '0') THEN
         current_state <= Reset;
         -- Reset Values
      ELSIF (Clk'EVENT AND Clk = '1') THEN
         current_state <= next_state;
         -- Default Assignment To Internals

      END IF;

   END PROCESS clocked;

   ----------------------------------------------------------------------------
   nextstate : PROCESS (
      MREAD_L,
      MWRITEH_L,
      MWRITEL_L,
      PMRESP_H,
      current_state,
      tag0match,
      tag1match
   )
   ----------------------------------------------------------------------------
   BEGIN
      CASE current_state IS
      WHEN Read_hit =>
         IF ((tag0match = '0') and (tag1match = '0')) THEN
            next_state <= Read_miss;
         ELSIF ((MWRITEL_L = '0') AND (MWRITEH_L = '0')) THEN
            next_state <= Write_hit1;
         ELSIF (MWRITEL_L = '0') THEN
            next_state <= Write_hit2;
         ELSIF (MWRITEH_L = '0') THEN
            next_state <= Write_hit3;
         ELSE
            next_state <= Read_hit;
         END IF;
      WHEN Read_miss =>
         IF ((MWRITEL_L = '0') AND (MWRITEH_L = '0')) THEN
            next_state <= Write_miss1;
         ELSIF (MWRITEL_L = '0') THEN
            next_state <= Write_miss2;
         ELSIF (MWRITEH_L = '0') THEN
            next_state <= Write_miss3;
         ELSIF (MREAD_L='0' and PMRESP_H = '1') THEN
            next_state <= UpdateData;
         ELSE
            next_state <= Read_miss;
         END IF;
      WHEN Write_hit2 =>
         IF (PMRESP_H = '1') THEN
            next_state <= UpdateData;
         ELSE
            next_state <= Write_hit2;
         END IF;
      WHEN Write_hit1 =>
         IF (PMRESP_H = '1') THEN
            next_state <= UpdateData;
         ELSE
            next_state <= Write_hit1;
         END IF;
      WHEN Write_hit3 =>
         IF (PMRESP_H = '1') THEN
            next_state <= UpdateData;
         ELSE
            next_state <= Write_hit3;
         END IF;
      WHEN Reset =>
            next_state <= Read_hit;
      WHEN UpdateData =>
            next_state <= UpdateLRU;
      WHEN Write_miss1 =>
         IF (PMRESP_H = '1') THEN
            next_state <= UpdateData;
         ELSE
            next_state <= Write_miss1;
         END IF;
      WHEN Write_miss2 =>
         IF (PMRESP_H = '1') THEN
            next_state <= UpdateData;
         ELSE
            next_state <= Write_miss2;
         END IF;
      WHEN Write_miss3 =>
         IF (PMRESP_H = '1') THEN
            next_state <= UpdateData;
         ELSE
            next_state <= Write_miss3;
         END IF;
      WHEN UpdateLRU =>
            next_state <= Read_hit;
      WHEN OTHERS =>
         next_state <= Reset;
      END CASE;

   END PROCESS nextstate;

   ----------------------------------------------------------------------------
   output : PROCESS (
      Address,
      Data_cacheout,
      Data_wordout,
      Dataout,
      MWRITEH_L,
      MWRITEL_L,
      current_state,
      lrusel,
      tag0match,
      tag1match
   )
   ----------------------------------------------------------------------------
   BEGIN
      -- Default Assignment
      DataIn <= Data_wordout;
      LineSel <= '0';
      MRESP_H <= '0';
      PMAddress <= Address;
      PMDataOut <= Data_cacheout;
      PMREAD_L <= '1';
      PMWRITE_L <= '1';
      WriteEn0 <= '0';
      WriteEn1 <= '0';
      index <= Address(6 downto 3);
      lruload <= '0';
      lruupdate <= '1';
      offset <= Address(2 downto 0);
      tag <= Address(15 downto 7);
      -- Default Assignment To Internals

      -- Combined Actions
      CASE current_state IS
      WHEN Read_hit =>
         DataIn <= Data_wordout;
         if (tag0match = '1') then
            LineSel <= '0';
            lruupdate <= '0';
         elsif (tag1match = '1') then
            LineSel <= '1';
            lruupdate <= '1';
         end if;
         IF ((tag0match = '0') and (tag1match = '0')) THEN
         ELSIF ((MWRITEL_L = '0') AND (MWRITEH_L = '0')) THEN
            LRUload <= '0';
         ELSIF (MWRITEL_L = '0') THEN
            LRUload <= '0';
         ELSIF (MWRITEH_L = '0') THEN
            LRUload <= '0';
         ELSE
            MRESP_H <= '1';
         END IF;
      WHEN Read_miss =>
         pmread_L <= '0';
      WHEN Write_hit2 =>
         case address(2 downto 0) is
            when "000" =>
               PMDataOut <= (Data_cacheout(63 downto 8) & DataOut(7 downto 0));      
            when "010" =>
               PMDataOut <= (Data_cacheout(63 downto 24) & DataOut(7 downto 0) & Data_cacheout(15 downto 0));      
            when "011" =>
               PMDataOut <= (Data_cacheout(63 downto 32) & DataOut(7 downto 0) & Data_cacheout(23 downto 0));      
            when "100" =>
               PMDataOut <= (Data_cacheout(63 downto 40) & DataOut(7 downto 0) & Data_cacheout(31 downto 0));      
            when "110" =>
               PMDataOut <= (Data_cacheout(63 downto 56) & DataOut(7 downto 0) & Data_cacheout(47 downto 0)); 
            when Others =>
               PMDataOut <= Data_cacheout;       
         end case;
         PMWRITE_L <= '0';
      WHEN Write_hit1 =>
         case address(2 downto 0) is
            when "000" =>
               PMDataOut <= (Data_cacheout(63 downto 16) & DataOut);      
            when "010" =>
               PMDataOut <= (Data_cacheout(63 downto 32) & DataOut & Data_cacheout(15 downto 0));      
            when "100" =>
               PMDataOut <= (Data_cacheout(63 downto 48) & DataOut & Data_cacheout(31 downto 0));      
             when "101" =>
               PMDataOut <= (Data_cacheout(63 downto 56) & DataOut & Data_cacheout(39 downto 0));       
           when "110" =>
               PMDataOut <= (DataOut & Data_cacheout(47 downto 0));      
            when Others =>
               PMDataOut <= Data_cacheout;  
         end case;
         PMWRITE_L <= '0';
      WHEN Write_hit3 =>
         case address(2 downto 0) is
            when "000" =>
               PMDataOut <= (Data_cacheout(63 downto 16) & DataOut(15 downto 8) & Data_cacheout(7 downto 0));      
            when "010" =>
               PMDataOut <= (Data_cacheout(63 downto 32) & DataOut(15 downto 8) & Data_cacheout(23 downto 0));      
            when "100" =>
               PMDataOut <= (Data_cacheout(63 downto 48) & DataOut(15 downto 8) & Data_cacheout(39 downto 0));      
            when "110" =>
               PMDataOut <= (DataOut(15 downto 8) & Data_cacheout(55 downto 0)); 
            when Others =>
               PMDataOut <= Data_cacheout;       
         end case;
         PMWRITE_L <= '0';
      WHEN UpdateData =>
         if (lrusel = '1') then
            WriteEn0 <= '1';
         else
            WriteEn1 <= '1';
         end if;
      WHEN Write_miss1 =>
         case address(2 downto 0) is
            when "000" =>
               PMDataOut <= (Data_cacheout(63 downto 16) & DataOut);      
            when "010" =>
               PMDataOut <= (Data_cacheout(63 downto 32) & DataOut & Data_cacheout(15 downto 0));      
            when "100" =>
               PMDataOut <= (Data_cacheout(63 downto 48) & DataOut & Data_cacheout(31 downto 0));      
            when "101" =>
               PMDataOut <= (Data_cacheout(63 downto 56) & DataOut & Data_cacheout(39 downto 0));
            when "110" =>
               PMDataOut <= (DataOut & Data_cacheout(47 downto 0));   
            when Others =>
               PMDataOut <= Data_cacheout;   
         end case;
         PMWRITE_L <= '0';
      WHEN Write_miss2 =>
         case address(2 downto 0) is
            when "000" =>
               PMDataOut <= (Data_cacheout(63 downto 8) & DataOut(7 downto 0));      
            when "010" =>
               PMDataOut <= (Data_cacheout(63 downto 24) & DataOut(7 downto 0) & Data_cacheout(15 downto 0));      
            when "100" =>
               PMDataOut <= (Data_cacheout(63 downto 40) & DataOut(7 downto 0) & Data_cacheout(31 downto 0));      
            when "110" =>
               PMDataOut <= (Data_cacheout(63 downto 56) & DataOut(7 downto 0) & Data_cacheout(47 downto 0));   
            when Others =>
               PMDataOut <= Data_cacheout;   
         end case;
         PMWRITE_L <= '0';
      WHEN Write_miss3 =>
         case address(2 downto 0) is
            when "000" =>
               PMDataOut <= (Data_cacheout(63 downto 8) & DataOut(7 downto 0));      
            when "010" =>
               PMDataOut <= (Data_cacheout(63 downto 24) & DataOut(7 downto 0) & Data_cacheout(15 downto 0));      
            when "100" =>
               PMDataOut <= (Data_cacheout(63 downto 40) & DataOut(7 downto 0) & Data_cacheout(31 downto 0));      
            when "110" =>
               PMDataOut <= (Data_cacheout(63 downto 56) & DataOut(7 downto 0) & Data_cacheout(47 downto 0));    
            when Others =>
               PMDataOut <= Data_cacheout;  
         end case;
         PMWRITE_L <= '0';
      WHEN UpdateLRU =>
         if (lrusel = '1') then
           WriteEn0 <= '0';
           lruupdate <= '0';
         elsif (lrusel = '0') then
           WriteEn1 <= '0';
           lruupdate <= '1';
         end if;
         lruload <= '1';
         MRESP_H <= '1';
      WHEN OTHERS =>
         NULL;
      END CASE;

   END PROCESS output;

   -- Concurrent Statements

END fsm;
